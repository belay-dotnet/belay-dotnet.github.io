name: Deploy VitePress site to Pages

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: pages
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      build-success: ${{ steps.build-validation.outputs.success }}
      site-health: ${{ steps.site-health.outputs.healthy }}
    steps:
      - name: Checkout docs repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Checkout main Belay.NET repository
        uses: actions/checkout@v4
        with:
          repository: belay-dotnet/Belay.NET
          path: belay-source
          fetch-depth: 1
          
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.x'
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: npm
          
      - name: Setup Pages
        uses: actions/configure-pages@v4
        
      - name: Install dependencies
        run: npm ci
        
      - name: Build .NET projects for XML documentation
        run: |
          cd belay-source
          echo "Building .NET projects to generate XML documentation..."
          dotnet restore
          dotnet build --configuration Release --verbosity minimal
          
      - name: Install Python for API doc generation
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
          
      - name: Generate API documentation from XML
        run: |
          echo "Generating API documentation..."
          
          # Create a reliable version of the API documentation script
          cat > generate-api-docs-ci.py << 'EOF'
          #!/usr/bin/env python3
          
          """
          Convert XML documentation to comprehensive markdown API documentation
          CI version that works with XML files copied to xml-docs directory
          """
          
          import xml.etree.ElementTree as ET
          import os
          import re
          from pathlib import Path
          from collections import defaultdict
          import glob
          
          def clean_xml_text(text):
              """Clean up XML text content"""
              if not text:
                  return ""
              # Remove extra whitespace and normalize
              text = re.sub(r'\s+', ' ', text.strip())
              # Escape angle brackets to prevent Vue parsing issues
              text = text.replace('<', '&lt;').replace('>', '&gt;')
              # Convert some common XML doc tags to markdown (after escaping)
              text = text.replace('&lt;c&gt;', '`').replace('&lt;/c&gt;', '`')
              text = re.sub(r'&lt;see cref="T:([^"]+)"/&gt;', r'`\1`', text)
              text = re.sub(r'&lt;see cref="M:([^"]+)"/&gt;', r'`\1`', text)  
              text = re.sub(r'&lt;see cref="P:([^"]+)"/&gt;', r'`\1`', text)
              text = re.sub(r'&lt;paramref name="([^"]+)"/&gt;', r'`\1`', text)
              return text
          
          def extract_code_examples(text):
              """Extract code examples from XML documentation"""
              if not text:
                  return ""
              
              # Find <code> blocks
              code_blocks = re.findall(r'<code>(.*?)</code>', text, re.DOTALL)
              markdown_code = ""
              
              for code in code_blocks:
                  # Clean up the code
                  code = re.sub(r'^\s*///', '', code, flags=re.MULTILINE)
                  code = code.strip()
                  if code:
                      # Determine language (simple heuristic)
                      lang = "csharp" if any(keyword in code for keyword in ["public", "class", "using", "await", "var"]) else ""
                      markdown_code += f"\n```{lang}\n{code}\n```\n"
              
              return markdown_code
          
          def process_member(member, member_type):
              """Process a single member (method, property, etc.)"""
              name = member.get('name', '')
              
              # Remove type prefix (T:, M:, P:, F:)
              clean_name = name[2:] if name.startswith(('T:', 'M:', 'P:', 'F:')) else name
              
              # Get summary
              summary_elem = member.find('summary')
              summary = clean_xml_text(summary_elem.text if summary_elem is not None else "")
              
              # Get remarks
              remarks_elem = member.find('remarks')
              remarks = clean_xml_text(remarks_elem.text if remarks_elem is not None else "")
              
              # Get example
              example_elem = member.find('example')
              example = ""
              if example_elem is not None:
                  example_text = ET.tostring(example_elem, encoding='unicode', method='text')
                  example = clean_xml_text(example_text)
                  # Also check for code blocks
                  example += extract_code_examples(ET.tostring(example_elem, encoding='unicode'))
              
              # Get parameters (for methods)
              params = []
              for param in member.findall('param'):
                  param_name = param.get('name', '')
                  param_text = clean_xml_text(param.text or '')
                  if param_name and param_text:
                      params.append((param_name, param_text))
              
              # Get return value
              returns_elem = member.find('returns')
              returns = clean_xml_text(returns_elem.text if returns_elem is not None else "")
              
              # Get exceptions
              exceptions = []
              for exception in member.findall('exception'):
                  exc_type = exception.get('cref', '')
                  exc_text = clean_xml_text(exception.text or '')
                  if exc_type and exc_text:
                      # Clean up cref format
                      exc_type = exc_type.replace('T:', '')
                      exceptions.append((exc_type, exc_text))
              
              return {
                  'name': clean_name,
                  'summary': summary,
                  'remarks': remarks,
                  'example': example,
                  'parameters': params,
                  'returns': returns,
                  'exceptions': exceptions,
                  'member_type': member_type
              }
          
          def process_xml_file(xml_path):
              """Convert XML documentation to markdown"""
              try:
                  tree = ET.parse(xml_path)
                  root = tree.getroot()
                  
                  assembly_name = root.find('assembly/name').text
                  output_dir = Path(f"api/generated/{assembly_name}")
                  output_dir.mkdir(parents=True, exist_ok=True)
                  
                  # Group members by namespace and type
                  namespaces = defaultdict(lambda: defaultdict(list))
                  types = {}
                  
                  # First pass: collect all types and organize by namespace
                  for member in root.findall('.//member'):
                      name = member.get('name', '')
                      
                      if name.startswith('T:'):  # Type
                          type_info = process_member(member, 'type')
                          full_name = type_info['name']
                          
                          # Extract namespace
                          if '.' in full_name:
                              namespace = '.'.join(full_name.split('.')[:-1])
                              type_name = full_name.split('.')[-1]
                          else:
                              namespace = assembly_name
                              type_name = full_name
                          
                          types[full_name] = type_info
                          namespaces[namespace]['types'].append((type_name, full_name, type_info))
                  
                  # Second pass: collect members for each type
                  for member in root.findall('.//member'):
                      name = member.get('name', '')
                      
                      if name.startswith('M:'):  # Method
                          member_info = process_member(member, 'method')
                          # Find parent type
                          method_name = member_info['name']
                          if '(' in method_name:
                              method_name = method_name.split('(')[0]  # Remove parameters
                          type_name = '.'.join(method_name.split('.')[:-1])
                          if type_name in types:
                              if 'methods' not in types[type_name]:
                                  types[type_name]['methods'] = []
                              types[type_name]['methods'].append(member_info)
                                  
                      elif name.startswith('P:'):  # Property
                          member_info = process_member(member, 'property')
                          # Find parent type
                          prop_name = member_info['name']
                          type_name = '.'.join(prop_name.split('.')[:-1])
                          if type_name in types:
                              if 'properties' not in types[type_name]:
                                  types[type_name]['properties'] = []
                              types[type_name]['properties'].append(member_info)
                                  
                      elif name.startswith('F:'):  # Field
                          member_info = process_member(member, 'field')
                          # Find parent type
                          field_name = member_info['name']
                          type_name = '.'.join(field_name.split('.')[:-1])
                          if type_name in types:
                              if 'fields' not in types[type_name]:
                                  types[type_name]['fields'] = []
                              types[type_name]['fields'].append(member_info)
                  
                  # Generate main README
                  with open(output_dir / "README.md", "w") as f:
                      f.write(f"# {assembly_name} API Reference\n\n")
                      f.write("Comprehensive API documentation generated from XML documentation comments.\n\n")
                      f.write("## Table of Contents\n\n")
                      
                      # Create table of contents
                      for namespace, namespace_data in sorted(namespaces.items()):
                          if namespace_data['types']:
                              f.write(f"### {namespace}\n\n")
                              for type_name, full_name, type_info in sorted(namespace_data['types']):
                                  f.write(f"- [{type_name}](#{full_name.lower().replace('.', '').replace('<', '').replace('>', '').replace('`', '')})\n")
                              f.write("\n")
                      
                      f.write("\n---\n\n")
                      
                      # Generate detailed documentation
                      for namespace, namespace_data in sorted(namespaces.items()):
                          if namespace_data['types']:
                              f.write(f"## {namespace}\n\n")
                              
                              for type_name, full_name, type_info in sorted(namespace_data['types']):
                                  # Create anchor-friendly ID
                                  type_id = full_name.lower().replace('.', '').replace('<', '').replace('>', '').replace('`', '')
                                  f.write(f"### {full_name} {{#{type_id}}}\n\n")
                                  
                                  if type_info['summary']:
                                      f.write(f"{type_info['summary']}\n\n")
                                  
                                  if type_info['remarks']:
                                      f.write(f"**Remarks**: {type_info['remarks']}\n\n")
                                  
                                  if type_info['example']:
                                      f.write(f"**Example**:\n{type_info['example']}\n\n")
                                  
                                  # Add properties
                                  if 'properties' in type_info:
                                      f.write("#### Properties\n\n")
                                      for prop in sorted(type_info['properties'], key=lambda x: x['name']):
                                          prop_name = prop['name'].split('.')[-1]
                                          f.write(f"**{prop_name}**\n\n")
                                          if prop['summary']:
                                              f.write(f"{prop['summary']}\n\n")
                                          if prop['remarks']:
                                              f.write(f"*Remarks*: {prop['remarks']}\n\n")
                                  
                                  # Add methods
                                  if 'methods' in type_info:
                                      f.write("#### Methods\n\n")
                                      for method in sorted(type_info['methods'], key=lambda x: x['name']):
                                          method_name = method['name'].split('.')[-1]
                                          if '(' in method_name:
                                              method_name = method_name.split('(')[0]
                                          f.write(f"**{method_name}**\n\n")
                                          if method['summary']:
                                              f.write(f"{method['summary']}\n\n")
                                          
                                          if method['parameters']:
                                              f.write("*Parameters*:\n")
                                              for param_name, param_desc in method['parameters']:
                                                  f.write(f"- `{param_name}`: {param_desc}\n")
                                              f.write("\n")
                                          
                                          if method['returns']:
                                              f.write(f"*Returns*: {method['returns']}\n\n")
                                          
                                          if method['exceptions']:
                                              f.write("*Exceptions*:\n")
                                              for exc_type, exc_desc in method['exceptions']:
                                                  f.write(f"- `{exc_type}`: {exc_desc}\n")
                                              f.write("\n")
                                          
                                          if method['remarks']:
                                              f.write(f"*Remarks*: {method['remarks']}\n\n")
                                          
                                          if method['example']:
                                              f.write(f"*Example*:\n{method['example']}\n\n")
                                  
                                  # Add fields
                                  if 'fields' in type_info:
                                      f.write("#### Fields\n\n")
                                      for field in sorted(type_info['fields'], key=lambda x: x['name']):
                                          field_name = field['name'].split('.')[-1]
                                          f.write(f"**{field_name}**\n\n")
                                          if field['summary']:
                                              f.write(f"{field['summary']}\n\n")
                                  
                                  f.write("---\n\n")
                  
                  print(f"‚úì Generated comprehensive documentation for {assembly_name}")
                  return True
                  
              except Exception as e:
                  print(f"‚úó Error processing {xml_path}: {e}")
                  import traceback
                  traceback.print_exc()
                  return False
          
          def main():
              """Main function to process XML files from xml-docs directory"""
              # Look for XML files in belay-source
              xml_files = glob.glob("belay-source/src/*/bin/Release/net8.0/*.xml")
              xml_files = [f for f in xml_files if "ref" not in f]  # Skip reference assemblies
              
              success_count = 0
              for xml_file in xml_files:
                  if process_xml_file(xml_file):
                      success_count += 1
              
              print(f"\n‚úì Successfully processed {success_count} XML documentation files")
              
              # Update main API index
              if os.path.exists("api/generated"):
                  print("‚úì Updating main API index...")
                  with open("api/index.md", "w") as f:
                      f.write("# API Reference\n\n")
                      f.write("Comprehensive API documentation automatically generated from XML comments in the source code.\n\n")
                      f.write("## Generated Documentation\n\n")
                      
                      # Add links to generated docs
                      generated_dirs = [d for d in os.listdir("api/generated") if os.path.isdir(f"api/generated/{d}")]
                      for assembly in sorted(generated_dirs):
                          f.write(f"- **[{assembly}](./generated/{assembly}/README.md)** - {assembly} namespace documentation\n")
                      
                      f.write("\n## Quick Reference\n\n")
                      f.write("### Core Classes\n")
                      f.write("- **Device** - Main device connection and communication\n")
                      f.write("- **TaskExecutor** - Handles [Task] attribute methods\n")
                      f.write("- **EnhancedExecutor** - Advanced method interception framework\n")
                      f.write("- **DeviceProxy** - Dynamic proxy for transparent method routing\n\n")
                      f.write("### Attributes\n")
                      f.write("- **TaskAttribute** - Execute methods as tasks with caching and timeout\n")
                      f.write("- **ThreadAttribute** - Background thread execution\n")
                      f.write("- **SetupAttribute** - Device initialization methods\n")
                      f.write("- **TeardownAttribute** - Device cleanup methods\n\n")
                      f.write("For detailed documentation, see the generated API reference above.\n\n")
                      f.write("## Usage Examples\n\n")
                      f.write("For practical examples of using these APIs, see the [Examples](/examples/) section.\n")
                  
                  print("‚úì Main API index updated")
          
          if __name__ == "__main__":
              main()
          EOF
          
          # Make the script executable and run it
          chmod +x generate-api-docs-ci.py
          python3 generate-api-docs-ci.py
          
          echo "API documentation generation completed"
          
      - name: Build with VitePress
        run: |
          echo "üîÑ Building VitePress documentation..."
          
          # Build and capture output
          if npm run build > vitepress_build.log 2>&1; then
            echo "‚úÖ VitePress build succeeded"
          else
            echo "‚ùå VitePress build failed!"
            cat vitepress_build.log
            exit 1
          fi
          
          # Verify dist directory was created
          if [ ! -d ".vitepress/dist" ]; then
            echo "‚ùå VitePress dist directory not created!"
            exit 1
          fi
          
          echo "‚úÖ VitePress build completed successfully"
          touch .vitepress/dist/.nojekyll
          
      - name: Validate build output
        id: build-validation
        run: |
          echo "üîç Validating build output..."
          
          # Check for essential files
          REQUIRED_FILES=(".vitepress/dist/index.html" ".vitepress/dist/api/index.html")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "‚ùå Required file missing: $file"
              echo "success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          done
          
          # Check file sizes (detect empty or corrupted files)
          if [ ! -s ".vitepress/dist/index.html" ]; then
            echo "‚ùå Main index.html is empty"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check for broken build artifacts
          if grep -r "404" .vitepress/dist/assets/ 2>/dev/null; then
            echo "‚ùå Build contains 404 references"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Count generated files
          FILE_COUNT=$(find .vitepress/dist -name "*.html" | wc -l)
          if [ $FILE_COUNT -lt 10 ]; then
            echo "‚ùå Too few HTML files generated ($FILE_COUNT), build likely incomplete"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Build validation passed - $FILE_COUNT HTML files generated"
          echo "success=true" >> $GITHUB_OUTPUT
          
      - name: Site health check
        id: site-health
        run: |
          echo "üè• Running comprehensive site health checks..."
          
          # Start a local server to test the built site
          cd .vitepress/dist
          python3 -m http.server 8080 &
          SERVER_PID=$!
          sleep 3
          
          # Test critical pages
          CRITICAL_PAGES=("/" "/api/" "/api/versions" "/guide/getting-started")
          HEALTH_SCORE=0
          
          for page in "${CRITICAL_PAGES[@]}"; do
            echo "Testing page: $page"
            if curl -f -s "http://localhost:8080$page" > /dev/null; then
              echo "‚úÖ $page - OK"
              ((HEALTH_SCORE++))
            else
              echo "‚ùå $page - FAILED"
            fi
          done
          
          # Kill the test server
          kill $SERVER_PID 2>/dev/null || true
          
          # Require at least 75% of critical pages to work
          REQUIRED_SCORE=$((${#CRITICAL_PAGES[@]} * 3 / 4))
          if [ $HEALTH_SCORE -lt $REQUIRED_SCORE ]; then
            echo "‚ùå Site health check failed: $HEALTH_SCORE/${#CRITICAL_PAGES[@]} pages working"
            echo "healthy=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Site health check passed: $HEALTH_SCORE/${#CRITICAL_PAGES[@]} pages working"
          echo "healthy=true" >> $GITHUB_OUTPUT
          
      - name: Create deployment summary
        if: steps.build-validation.outputs.success == 'true' && steps.site-health.outputs.healthy == 'true'
        run: |
          echo "üìã Deployment Summary:" > deployment-summary.txt
          echo "‚úÖ VitePress build: SUCCESS" >> deployment-summary.txt
          echo "‚úÖ Build validation: SUCCESS" >> deployment-summary.txt
          echo "‚úÖ Site health check: SUCCESS" >> deployment-summary.txt
          echo "üìä Generated files: $(find .vitepress/dist -name '*.html' | wc -l) HTML pages" >> deployment-summary.txt
          echo "üïê Build time: $(date)" >> deployment-summary.txt
          cat deployment-summary.txt
          cp deployment-summary.txt .vitepress/dist/
          
      - name: Upload artifact
        if: steps.build-validation.outputs.success == 'true' && steps.site-health.outputs.healthy == 'true'
        uses: actions/upload-pages-artifact@v3
        with:
          path: .vitepress/dist
          
      - name: Build failed - Create error report
        if: steps.build-validation.outputs.success != 'true' || steps.site-health.outputs.healthy != 'true'
        run: |
          echo "‚ùå DEPLOYMENT BLOCKED - Build validation or health check failed!"
          echo "Build validation: ${{ steps.build-validation.outputs.success }}"
          echo "Site health: ${{ steps.site-health.outputs.healthy }}"
          
          # Create detailed error report
          echo "üîç Error Report:" > error-report.txt
          echo "Build validation: ${{ steps.build-validation.outputs.success }}" >> error-report.txt
          echo "Site health: ${{ steps.site-health.outputs.healthy }}" >> error-report.txt
          echo "Timestamp: $(date)" >> error-report.txt
          
          if [ -f "vitepress_build.log" ]; then
            echo "VitePress build log:" >> error-report.txt
            cat vitepress_build.log >> error-report.txt
          fi
          
          cat error-report.txt
          exit 1

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    needs: build
    runs-on: ubuntu-latest
    name: Deploy
    # Only deploy if build passed all validations
    if: needs.build.outputs.build-success == 'true' && needs.build.outputs.site-health == 'true'
    steps:
      - name: Pre-deployment validation
        run: |
          echo "üöÄ Starting validated deployment..."
          echo "Build validation: ${{ needs.build.outputs.build-success }}"
          echo "Site health: ${{ needs.build.outputs.site-health }}"
          
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        
      - name: Post-deployment verification
        run: |
          echo "‚è∞ Waiting 30 seconds for deployment to propagate..."
          sleep 30
          
          # Test the deployed site
          SITE_URL="${{ steps.deployment.outputs.page_url }}"
          echo "üåê Testing deployed site: $SITE_URL"
          
          # Test critical pages
          PAGES=("" "api/" "api/versions" "guide/getting-started")
          FAILED_PAGES=()
          
          for page in "${PAGES[@]}"; do
            URL="${SITE_URL}${page}"
            echo "Testing: $URL"
            if curl -f -s --max-time 10 "$URL" > /dev/null; then
              echo "‚úÖ $URL - OK"
            else
              echo "‚ùå $URL - FAILED"
              FAILED_PAGES+=("$URL")
            fi
          done
          
          if [ ${#FAILED_PAGES[@]} -gt 0 ]; then
            echo "‚ö†Ô∏è Warning: ${#FAILED_PAGES[@]} page(s) failed post-deployment verification:"
            printf '%s\n' "${FAILED_PAGES[@]}"
            echo "This may indicate deployment propagation delays or configuration issues."
          else
            echo "‚úÖ All pages verified successfully!"
          fi
          
  # Separate job to handle deployment failures
  deployment-failed:
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.build-success != 'true' || needs.build.outputs.site-health != 'true'
    steps:
      - name: Deployment blocked notification
        run: |
          echo "üö´ DEPLOYMENT BLOCKED"
          echo "The website build failed validation and deployment has been prevented."
          echo "Build validation: ${{ needs.build.outputs.build-success }}"
          echo "Site health: ${{ needs.build.outputs.site-health }}"
          echo ""
          echo "The live website remains unchanged to prevent breakage."
          echo "Check the build job logs for detailed error information."
          exit 1