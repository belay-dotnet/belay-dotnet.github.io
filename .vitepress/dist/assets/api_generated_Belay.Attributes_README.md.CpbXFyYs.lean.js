import{_ as l,c as p,o as t,ag as n,j as e,a as r,t as i}from"./chunks/framework.CUqMdM43.js";const u=JSON.parse('{"title":"Belay.Attributes API Reference","description":"","frontmatter":{},"headers":[],"relativePath":"api/generated/Belay.Attributes/README.md","filePath":"api/generated/Belay.Attributes/README.md"}'),h={name:"api/generated/Belay.Attributes/README.md"};function k(a,s,c,d,o,b){return t(),p("div",null,[s[1]||(s[1]=n("",74)),e("p",null,[s[0]||(s[0]=e("strong",null,"Example",-1)),r(`: Continuous Sensor Monitoring public class EnvironmentMonitor : Device { [Thread] public async Task StartContinuousMonitoringAsync(int intervalMs = 1000) { await ExecuteAsync($@" import _thread import time import machine def monitor_environment(): adc = machine.ADC(machine.Pin(26)) while globals().get('monitoring_active', True): try: # Read sensor values temp = read_temperature(adc) humidity = read_humidity() # Log or transmit data print(f'Temp: `+i(a.temp)+"C, Humidity: "+i(a.humidity)+"%') time.sleep_ms({intervalMs}) except Exception as e: print(f'Monitoring error: "+i(a.e)+`') time.sleep_ms(5000) # Back off on error # Start monitoring thread _thread.start_new_thread(monitor_environment, ()) "); } [Task] public async Task StopMonitoringAsync() { await ExecuteAsync("monitoring_active = False"); } } Event-Driven Responses public class ButtonHandler : Device { [Thread] public async Task StartButtonWatcherAsync() { await ExecuteAsync(@" import _thread import machine import time def watch_buttons(): button1 = machine.Pin(2, machine.Pin.IN, machine.Pin.PULL_UP) button2 = machine.Pin(3, machine.Pin.IN, machine.Pin.PULL_UP) last_state = [True, True] # Pulled up initially while globals().get('button_watching', True): current_state = [button1.value(), button2.value()] # Check for button presses (high to low transition) for i, (last, current) in enumerate(zip(last_state, current_state)): if last and not current: # Button pressed print(f'Button {i+1} pressed!') handle_button_press(i+1) last_state = current_state time.sleep_ms(50) # 50ms polling _thread.start_new_thread(watch_buttons, ()) "); } } Watchdog and Health Monitoring public class SystemMonitor : Device { [Thread(Name = "system_watchdog")] public async Task StartSystemWatchdogAsync() { await ExecuteAsync(@" import _thread import machine import gc import time def system_watchdog(): last_heartbeat = time.ticks_ms() while globals().get('watchdog_active', True): try: current_time = time.ticks_ms() # Check system health free_mem = gc.mem_free() if free_mem < 1000: # Low memory warning print(f'WARNING: Low memory: `+i(a.free_mem)+` bytes') gc.collect() # Check for system heartbeat if time.ticks_diff(current_time, last_heartbeat) > 30000: print('WARNING: No heartbeat for 30 seconds') # Update heartbeat if main loop is responsive if globals().get('system_heartbeat', 0) > last_heartbeat: last_heartbeat = globals()['system_heartbeat'] time.sleep_ms(5000) # Check every 5 seconds except Exception as e: print(f'Watchdog error: {e}') time.sleep_ms(10000) # Back off on error _thread.start_new_thread(system_watchdog, ()) "); } }`,1)]),s[2]||(s[2]=n("",30))])}const F=l(h,[["render",k]]);export{u as __pageData,F as default};
