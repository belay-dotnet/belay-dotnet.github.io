import{_ as s,C as r,c as i,o,ag as t,j as l,a,G as p}from"./chunks/framework.CUqMdM43.js";const u=JSON.parse('{"title":"Method ReadAsync","description":"","frontmatter":{},"headers":[],"relativePath":"api/generated/Belay.Core.Communication.DuplexStream.ReadAsync.md","filePath":"api/generated/Belay.Core.Communication.DuplexStream.ReadAsync.md"}'),c={name:"api/generated/Belay.Core.Communication.DuplexStream.ReadAsync.md"};function h(d,e,m,_,f,y){const n=r("xref");return o(),i("div",null,[e[2]||(e[2]=t('<h1 id="method-readasync" tabindex="-1"><a id="Belay_Core_Communication_DuplexStream_ReadAsync_System_Byte___System_Int32_System_Int32_System_Threading_CancellationToken_"></a> Method ReadAsync <a class="header-anchor" href="#method-readasync" aria-label="Permalink to &quot;&lt;a id=&quot;Belay_Core_Communication_DuplexStream_ReadAsync_System_Byte___System_Int32_System_Int32_System_Threading_CancellationToken_&quot;&gt;&lt;/a&gt; Method ReadAsync&quot;">​</a></h1><p>Namespace: <a href="./Belay.Core.Communication.html">Belay.Core.Communication</a><br> Assembly: Belay.Core.dll</p><h2 id="readasync-byte-int-int-cancellationtoken" tabindex="-1"><a id="Belay_Core_Communication_DuplexStream_ReadAsync_System_Byte___System_Int32_System_Int32_System_Threading_CancellationToken_"></a> ReadAsync(byte[], int, int, CancellationToken) <a class="header-anchor" href="#readasync-byte-int-int-cancellationtoken" aria-label="Permalink to &quot;&lt;a id=&quot;Belay_Core_Communication_DuplexStream_ReadAsync_System_Byte___System_Int32_System_Int32_System_Threading_CancellationToken_&quot;&gt;&lt;/a&gt; ReadAsync\\(byte\\[\\], int, int, CancellationToken\\)&quot;">​</a></h2><p>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</p><div class="language-csharp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> override</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ReadAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CancellationToken</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cancellationToken</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;Parameters&quot;">​</a></h3><p><code>buffer</code> <a href="https://learn.microsoft.com/dotnet/api/system.byte" target="_blank" rel="noreferrer">byte</a>[]</p><p>The buffer to write the data into.</p><p><code>offset</code> <a href="https://learn.microsoft.com/dotnet/api/system.int32" target="_blank" rel="noreferrer">int</a></p><p>The byte offset in <code class="paramref">buffer</code> at which to begin writing data from the stream.</p><p><code>count</code> <a href="https://learn.microsoft.com/dotnet/api/system.int32" target="_blank" rel="noreferrer">int</a></p><p>The maximum number of bytes to read.</p><p><code>cancellationToken</code> <a href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken" target="_blank" rel="noreferrer">CancellationToken</a></p>',13)),l("p",null,[e[0]||(e[0]=a("The token to monitor for cancellation requests. The default value is ",-1)),p(n,{href:"System.Threading.CancellationToken.None","data-throw-if-not-resolved":"false"}),e[1]||(e[1]=a(".",-1))]),e[3]||(e[3]=t('<h3 id="returns" tabindex="-1">Returns <a class="header-anchor" href="#returns" aria-label="Permalink to &quot;Returns&quot;">​</a></h3><p><a href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1" target="_blank" rel="noreferrer">Task</a>&lt;<a href="https://learn.microsoft.com/dotnet/api/system.int32" target="_blank" rel="noreferrer">int</a>&gt;</p><p>A task that represents the asynchronous read operation. The value of the <code class="paramref">TResult</code> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if <code class="paramref">count</code> is 0 or if the end of the stream has been reached.</p><h3 id="exceptions" tabindex="-1">Exceptions <a class="header-anchor" href="#exceptions" aria-label="Permalink to &quot;Exceptions&quot;">​</a></h3><p><a href="https://learn.microsoft.com/dotnet/api/system.argumentnullexception" target="_blank" rel="noreferrer">ArgumentNullException</a></p><p><code class="paramref">buffer</code> is <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/null">null</a>.</p><p><a href="https://learn.microsoft.com/dotnet/api/system.argumentoutofrangeexception" target="_blank" rel="noreferrer">ArgumentOutOfRangeException</a></p><p><code class="paramref">offset</code> or <code class="paramref">count</code> is negative.</p><p><a href="https://learn.microsoft.com/dotnet/api/system.argumentexception" target="_blank" rel="noreferrer">ArgumentException</a></p><p>The sum of <code class="paramref">offset</code> and <code class="paramref">count</code> is larger than the buffer length.</p><p><a href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception" target="_blank" rel="noreferrer">NotSupportedException</a></p><p>The stream does not support reading.</p><p><a href="https://learn.microsoft.com/dotnet/api/system.objectdisposedexception" target="_blank" rel="noreferrer">ObjectDisposedException</a></p><p>The stream has been disposed.</p><p><a href="https://learn.microsoft.com/dotnet/api/system.invalidoperationexception" target="_blank" rel="noreferrer">InvalidOperationException</a></p><p>The stream is currently in use by a previous read operation.</p>',16))])}const g=s(c,[["render",h]]);export{u as __pageData,g as default};
